## 1. Какие типы данных допустимы при создании таблицы?

При создании таблиц в PostgreSQL (и в реляционных базах данных в целом) столбцам назначаются определенные типы данных, которые определяют, какие значения они могут хранить. На основании ваших материалов, можно выделить следующие основные категории:

* **Символьные типы:** Используются для хранения текста.
  * `CHARACTER(n)` или `CHAR(n)`: Фиксированная строка длиной `n` символов. Если значение короче, оно дополняется пробелами.
  * `VARCHAR(n)`: Переменная строка с максимальной длиной `n` символов
* **Числовые типы:**
  * `INTEGER` или `INT`: Целое число. (4 байта)
  * `SMALLINT`: Малое целое число (2 байта).
* **Типы даты и времени:**
  * `DATE`: Хранит только дату (год, месяц, день).
* **Другие типы:** Существуют также вещественные числа (`REAL`, `DOUBLE PRECISION`), булевы значения (`BOOLEAN`) и т.д.

---

## 2. Как создать таблицу средствами языка SQL?

Создание таблицы осуществляется с помощью команды `CREATE TABLE`. Эта команда требует указать имя новой таблицы и список её столбцов с их типами данных.

**Синтаксис:**

```sql
CREATE TABLE имя_таблицы (
    имя_столбца1 тип_данных (ограничения),
    имя_столбца2 тип_данных (ограничения)

);
```

---

## 3. Как средствами языка SQL изменить структуру таблицы?

Структура существующей таблицы может быть изменена с помощью команды `ALTER TABLE`. Она позволяет добавлять, удалять или модифицировать столбцы и другие атрибуты таблицы.

**Основные операции:**

* **Добавление нового столбца:**
  ```sql
  ALTER TABLE имя_таблицы ADD COLUMN имя_столбца тип_данных;
  ```
* **Удаление столбца:**
  ```sql
  ALTER TABLE имя_таблицы DROP COLUMN имя_столбца;
  ```
* **Изменение типа данных столбца:**
  ```sql
  ALTER TABLE имя_таблицы ALTER COLUMN имя_столбца TYPE новый_тип
  ```

---

## 4. Как разделяются операторы SQL в случае нескольких операторов в запросе?

Если в одном запросе необходимо выполнить несколько отдельных команд SQL, каждая команда должна заканчиваться точкой с запятой (`;`). Этот символ является стандартным **разделителем операторов** в SQL.

**Пример:**

```sql
INSERT INTO s VALUES ('S6','Новый', 25,'Москва');
UPDATE s SET reiting = reiting + 5 WHERE n_post = 'S6';
DELETE FROM s WHERE n_post = 'S6';
```

Этот блок содержит три отдельные команды (вставка, обновление, удаление), и каждая из них завершается `;`.

---

## 5. Каким образом выполнить простейшие операции вставки, модификации, удаления строк данных в таблице средствами SQL?

Эти операции выполняются с помощью трех основных команд манипулирования данными (DML):

* **Вставка (INSERT):** Добавляет новые строки в таблицу.
  
  ```sql
  INSERT INTO имя_таблицы (столбец1, столбец2, ...) VALUES (значение1, значение2, ...);
  ```
  
  > *Пример:* `INSERT INTO s VALUES ('S6','Алиса', 25,'Новосибирск');`
* **Модификация (UPDATE):** Изменяет значения в существующих строках.
  
  ```sql
  UPDATE имя_таблицы SET столбец = новое_значение WHERE условие;
  ```
  
  > *Пример:* `UPDATE s SET reiting = 25 WHERE n_post = 'S1';` — изменит рейтинг поставщика S1 на 25.
* **Удаление (DELETE):** Удаляет строки из таблицы.
  
  ```sql
  DELETE FROM имя_таблицы WHERE условие;
  ```
  
  > *Пример:* `DELETE FROM s WHERE n_post = 'S6';` — удалит поставщика с номером S6.

---

## 6. При помощи какого оператора можно удалить данные из ячейки таблицы?

В SQL нет специальной команды для "удаления" данных из одной ячейки, так как все операции производятся над строками. Чтобы очистить значение в конкретном столбце (ячейке), нужно использовать команду `UPDATE`, установив для этого столбца значение `NULL`.

**Синтаксис:**

```sql
UPDATE имя_таблицы SET имя_столбца = NULL WHERE условие_на_строку;
```

**Пример:**

```sql
UPDATE s SET town = NULL WHERE n_post = 'S1';
```

Этот запрос "удалит" значение из ячейки `town` для поставщика `S1`, установив его в состояние `NULL` (неопределенное значение).

---

## 7. Каким образом выполнить просмотр таблицы?

Для просмотра всех данных в таблице используется команда `SELECT` со специальным символом `*`, который означает "все столбцы".

**Синтаксис:**

```sql
SELECT * FROM имя_таблицы;
```

**Пример:**

```sql
SELECT * FROM s;
```

Этот запрос вернет все строки и все столбцы из таблицы `s` (поставщики).

---

## 8. Что такое rowid-столбец (oid-столбец)?

В PostgreSQL существует внутренний системный столбец, который называется `oid` (Object Identifier). Он не отображается в обычных запросах, но доступен для использования.

* **Назначение:** Каждая строка в таблице имеет уникальный внутренний идентификатор (`oid`). Это скрытый номер строки, который СУБД использует для однозначной идентификации и быстрого доступа к строкам.
* **Использование:** Его можно использовать в запросах, например, для поиска дубликатов или для точного указания строки при удалении/изменении, если нет другого уникального ключа.
* **Пример из материалов:** В документе `[Язык структурных запросов SQL.Начальное знакомство..pdf]` (стр. 21) говорится: "Для нахождения в таблице дубликата значения можно использовать в самосоединении скрытый oid-столбец." и приводится пример запроса с `x.oid != y.oid`.

---

## 9. Что такое ограничение первичного ключа, ограничение уникального ключа? В чем их различия?

Оба этих ограничения служат для обеспечения уникальности данных в столбце или группе столбцов.

* **Ограничение первичного ключа (PRIMARY KEY):**
  
  * Гарантирует, что значения в столбце (или комбинации столбцов) являются **уникальными** и **не могут быть NULL**.
  * Каждая таблица может иметь **только один** первичный ключ.
  * Первичный ключ однозначно идентифицирует каждую строку в таблице и является основным способом ссылки на эту строку из других таблиц (через внешние ключи).
  * *Пример:* `n_post` в таблице поставщиков — это первичный ключ, так как каждый поставщик имеет уникальный номер.
* **Ограничение уникального ключа (UNIQUE):**
  
  * Гарантирует, что значения в столбце (или комбинации столбцов) являются **уникальными**.
  * **Разрешает одно значение `NULL`** (в большинстве реализаций, включая PostgreSQL, хотя семантика может немного отличаться).
  * В одной таблице может быть **несколько** уникальных ключей.
  * Используется, когда нужно гарантировать уникальность, но столбец не является основным идентификатором строки.

**Ключевые различия:**

| Характеристика                       | Первичный ключ (PRIMARY KEY)                | Уникальный ключ (UNIQUE)                                                          |
| :------------------------------------------------- | :------------------------------------------------------- | :---------------------------------------------------------------------------------------------- |
| **Уникальность**                 | Да                                                     | Да                                                                                            |
| **Значения NULL**                    | Запрещены                                       | Разрешено одно `NULL`                                                            |
| **Количество на таблицу** | Только один                                    | Несколько                                                                              |
| **Основное назначение**    | Основной идентификатор строки | Обеспечение уникальности альтернативного атрибута |

---

## 10. Какие ограничения на столбцы таблицы можно задать?

SQL предоставляет несколько типов ограничений (constraints), которые можно применять к столбцам для обеспечения целостности данных. Основные из них:

* **`NOT NULL`:** Запрещает вставку или обновление строки, если в этом столбце указано значение `NULL`. Гарантирует, что столбец всегда будет содержать какое-либо значение.
* **`UNIQUE`:** Гарантирует, что все значения в столбце (или комбинации столбцов) будут уникальными.
* **`PRIMARY KEY`:** Комбинация `NOT NULL` и `UNIQUE`. Определяет столбец как первичный ключ таблицы.
* **`CHECK`:** Позволяет задать пользовательское условие, которому должно удовлетворять значение в столбце. Например, `CHECK (reiting > 0)` гарантирует, что рейтинг положительный.
* **`FOREIGN KEY`:** Создает связь между столбцом в одной таблице и первичным ключом в другой таблице. Гарантирует ссылочную целостность, то есть значение в столбце-ссылке должно существовать в связанной таблице.

---

## 11. Чем ограничение таблицы отличается от ограничения поля?

В языке SQL существует разница в уровне применения ограничений (constraints).

* **Ограничение поля (столбца)** — это ограничение, которое накладывается непосредственно на один конкретный столбец при его создании. Оно определяет допустимые значения или правила для этого столбца.
  
  * **Пример:** `CREATE TABLE S(n_post char(5) NOT NULL, ...)`. Здесь `NOT NULL` — это ограничение на поле `n_post`, запрещающее ему принимать пустые значения.
* **Ограничение таблицы** — это ограничение, которое объявляется как отдельное условие в списке определения столбцов и может ссылаться на несколько столбцов одновременно. Оно применяется ко всей строке таблицы в целом.
  
  * **Пример:** `ALTER TABLE SPJ ADD CONSTRAINT spj_pk PRIMARY KEY (n_post, n_det, n_izd);`. В этом случае первичный ключ задан на комбинацию трех столбцов (`n_post`, `n_det`, `n_izd`). Это ограничение не относится к каждому столбцу по отдельности, а определяет уникальность строки на основе их совокупности. Другой пример — внешний ключ, который также часто объявляется как ограничение таблицы: `ADD CONSTRAINT fk_spj_s FOREIGN KEY (n_post) REFERENCES s(n_post)`.

---

## 12. Что такое ограничение внешнего ключа? Как его задать?

**Ограничение внешнего ключа (Foreign Key Constraint)** — это механизм обеспечения **ссылочной целостности** между двумя таблицами. Оно устанавливает связь, при которой значение в одном столбце (или группе столбцов) одной таблицы должно соответствовать существующему значению в первичном ключе другой таблицы (или той же самой).

* **Назначение:** Гарантировать, что вы не сможете добавить запись в дочернюю таблицу (например, `SPJ`) со ссылкой на несуществующую запись в родительской таблице (например, `S`). Например, нельзя внести поставку от поставщика `S9`, если такого поставщика нет в таблице `S`.
* **Как задать:** Ограничение внешнего ключа можно задать двумя способами:
  1. **При создании таблицы**, используя ключевые слова `FOREIGN KEY` и `REFERENCES`.
     ```sql
     CREATE TABLE SPJ (
         n_post character(6),
         n_det character(6),
         n_izd character(6),
         kol smallint,
         FOREIGN KEY (n_post) REFERENCES S(n_post)
     );
     ```
  2. **После создания таблицы**, с помощью команды `ALTER TABLE`.
     ```sql
     ALTER TABLE SPJ ADD CONSTRAINT fk_spj_s FOREIGN KEY (n_post) REFERENCES S(n_post);
     ```

---

## 13. Какие проблемы могут возникнуть при работе с таблицей, у которой нет первичного ключа?

Отсутствие первичного ключа может привести к серьезным проблемам:

1. **Невозможность однозначной идентификации строк:** Без первичного ключа сложно точно указать, какую именно строку нужно изменить или удалить, особенно если все остальные поля имеют одинаковые значения. Это может привести к случайным изменениям нескольких строк.
2. **Дублирование данных:** Нет механизма для автоматического предотвращения вставки полностью идентичных строк, что нарушает целостность данных.
3. **Сложности с установлением связей:** Таблицы без первичного ключа не могут быть целевой стороной внешних ключей из других таблиц. Это делает невозможным построение нормализованной базы данных с четкими отношениями "один-ко-многим".
4. **Снижение производительности:** Первичные ключи автоматически индексируются. Их отсутствие затрудняет выполнение операций поиска, соединения и сортировки.
5. **Проблемы с репликацией и синхронизацией:** В распределенных системах отсутствие уникального идентификатора строки затрудняет синхронизацию данных между узлами.

---

## 14. Какое из ограничений может быть задано только одно на таблицу?

Только одно ограничение **первичного ключа (PRIMARY KEY)** может быть задано на одну таблицу.

* **Объяснение:** Первичный ключ служит основным уникальным идентификатором каждой строки в таблице. По определению, в таблице может быть только один такой основной ключ. Хотя он может состоять из нескольких столбцов (составной ключ), сама концепция "первичного" подразумевает единственность.
* **Важно:** На таблицу можно наложить множество других ограничений, таких как `UNIQUE`, `CHECK`, `FOREIGN KEY`. Например, у вас может быть один `PRIMARY KEY`, два разных `UNIQUE` ограничения на другие столбцы и три `FOREIGN KEY` на связь с другими таблицами.

---

## 15. Что такое коррелированный запрос? Чем отличается коррелированный запрос от некоррелированного?

* **Коррелированный подзапрос (Correlated Subquery)** — это подзапрос, который **зависит от значений во внешнем запросе**. Он выполняется повторно, **по одному разу для каждой строки**, которую рассматривает внешний запрос.
* **Некоррелированный подзапрос (Uncorrelated Subquery)** — это подзапрос, который **не зависит от внешнего запроса**. Он выполняется **только один раз**, до начала выполнения внешнего запроса, и его результат используется как константное множество.

**Ключевое отличие:**

* **Зависимость:** Коррелированный запрос содержит ссылку (корреляцию) на столбец из таблицы внешнего запроса.
* **Частота выполнения:** Некоррелированный запрос выполняется один раз; коррелированный — многократно (для каждой строки внешнего запроса).
* **Производительность:** Некоррелированные запросы обычно работают быстрее, так как выполняются всего один раз. Коррелированные могут быть медленнее, особенно на больших объемах данных, из-за множественного выполнения.

**Пример из материалов:**
Классический пример коррелированного запроса:

```sql
Select фамилия from S where'P2' in(Select номер_детали from SP where номер_поставщика= S.номер_поставщика)
```

Здесь внутренний подзапрос `Select номер_детали from SP where номер_поставщика = S.номер_поставщика` зависит от значения `S.номер_поставщика` из текущей строки внешнего запроса по таблице `S`. Для каждого поставщика система проверяет, поставляет ли он деталь 'P2'.

---

## 16. Какие существуют ограничения на формирование коррелированного запроса?

Основное и главное ограничение на формирование коррелированного запроса состоит в том, что **внутренний подзапрос должен содержать ссылку (корреляцию) на столбец из таблицы внешнего запроса.**

* **Формат ссылки:** Ссылка должна быть однозначной. Если в запросе используются псевдонимы таблиц (что настоятельно рекомендуется в коррелированных запросах), то столбец из внешнего запроса должен быть указан с этим псевдонимом.
* **Расположение:** Эта ссылка обычно находится в секции `WHERE` внутреннего подзапроса, где она сравнивается с каким-либо столбцом из таблицы, участвующей во внутреннем запросе.
* **Цель:** Эта ссылка создает зависимость ("корреляцию"), которая заставляет СУБД выполнять внутренний запрос для каждой строки внешнего запроса.

---

## 17. Каким образом сохранить результаты запроса в таблице?

Есть несколько способов сохранить результаты запроса в виде новой таблицы:

1. **Использование команды `CREATE TABLE AS`:** Это самый прямой способ. Создается новая таблица, и в нее сразу вставляются данные, полученные в результате запроса.
   
   ```sql
   CREATE TABLE temp AS (SELECT n_det, SUM(kol) as total_kol FROM SP GROUP BY n_det);
   ```
2. **Комбинация `CREATE TABLE` и `INSERT INTO ... SELECT ...`:** Сначала создается пустая таблица с нужной структурой, а затем в нее вставляются данные из запроса.
   
   ```sql
   CREATE TABLE temp (n_det character(6), total_kol smallint);
   INSERT INTO temp (n_det, total_kol) SELECT n_det, SUM(kol) FROM SP GROUP BY n_det;
   ```
3. **Использование команды `SELECT ... INTO`:** В некоторых диалектах SQL (включая PostgreSQL) существует конструкция `SELECT ... INTO`, которая объединяет создание таблицы и вставку данных.
   
   ```sql
   SELECT n_det, SUM(kol) as total_kol INTO temp FROM SP GROUP BY n_det;
   ```

---

## 18. Какими средствами SQL реализуются следующие операции реляционной алгебры:

Операции реляционной алгебры напрямую или косвенно транслируются в соответствующие конструкции языка SQL.

1. **Ограничение (Restriction):**
   
   * **Средство SQL:** Секция `WHERE`.
   * **Пояснение:** Операция ограничения выбирает из отношения (таблицы) только те кортежи (строки), которые удовлетворяют заданному условию. В SQL это выполняется с помощью условия фильтрации в спецификаторе `WHERE`. Например, запрос `SELECT * FROM S WHERE город='Лондон'` выбирает все строки из таблицы поставщиков, где значение столбца `город` равно 'Лондон'.
2. **Декартово произведение (Cartesian Product):**
   
   * **Средство SQL:** Ключевое слово `CROSS JOIN`.
   * **Пояснение:** Декартово произведение двух отношений создает новое отношение, содержащее все возможные комбинации строк из первого и второго отношения. В SQL для этого используется `CROSS JOIN`. Например, `SELECT * FROM S CROSS JOIN P` вернет все пары "поставщик-деталь", даже если между ними нет логической связи.
3. **Выбор (Selection):**
   
   * **Средство SQL:** Спецификатор `SELECT`.
   * **Пояснение:** Операция выбора проектирует отношение на подмножество его атрибутов (столбцов). В SQL за эту операцию отвечает сам оператор `SELECT`, который определяет, какие именно столбцы будут включены в результат. Например, `SELECT n_post, name FROM S` выбирает только номер и имя поставщика из таблицы `S`.
4. **Пересечение (Intersection):**
   
   * **Средство SQL:** Оператор `INTERSECT`.
   * **Пояснение:** Пересечение двух отношений создает новое отношение, содержащее только те кортежи, которые присутствуют в обоих исходных отношениях. В SQL для этого используется оператор `INTERSECT`. Например, `SELECT town FROM J INTERSECT SELECT town FROM P` вернет города, где производятся детали И СБИРАЮТСЯ изделия.
5. **Объединение (Union):**
   
   * **Средство SQL:** Оператор `UNION`.
   * **Пояснение:** Объединение двух отношений создает новое отношение, содержащее все кортежи из первого отношения и все кортежи из второго отношения, при этом дубликаты удаляются. В SQL для этого используется оператор `UNION`. Например, `SELECT town FROM P UNION SELECT town FROM S` вернет список всех уникальных городов, где есть либо детали, либо поставщики.
6. **Разность (Difference):**
   
   * **Средство SQL:** Оператор `EXCEPT`.
   * **Пояснение:** Разность двух отношений (A MINUS B) создает новое отношение, содержащее все кортежи из отношения A, которых нет в отношении B. В SQL для этого используется оператор `EXCEPT`. Например, `SELECT town FROM P EXCEPT SELECT town FROM S` вернет города, где производятся детали, но НЕТ поставщиков.
7. **Соединение (Join):**
   
   * **Средство SQL:** Ключевые слова `INNER JOIN`, `LEFT JOIN`, `RIGHT JOIN`, `FULL JOIN` с условием `ON`.
   * **Пояснение:** Операция соединения объединяет кортежи из двух отношений на основе некоторого условия. Наиболее распространена операция эквисоединения, которая соединяет строки по равенству значений ключевых полей. В SQL это реализуется с помощью различных типов `JOIN` и условия в спецификаторе `ON`. Например, `SELECT S.name, SP.kol FROM SP INNER JOIN S ON SP.n_post = S.n_post` соединяет таблицу поставок с таблицей поставщиков по номеру поставщика и выводит имя поставщика и количество деталей.

---

## 19. Что такое внешнее соединение?

**Внешнее соединение (Outer Join)** — это разновидность операции соединения, которая, в отличие от внутреннего соединения, сохраняет строки из одной или обеих таблиц, даже если для них не находится соответствия в другой таблице. Для таких строк, где совпадение отсутствует, поля из "пропущенной" таблицы заполняются значением `NULL`.

* **Зачем нужно:** Внутреннее соединение (`INNER JOIN`) "отбрасывает" строки, которые не имеют пары. Внешнее соединение позволяет сохранить всю информацию из основной таблицы, даже если для некоторых ее строк нет данных во второй таблице.
* **Типы внешних соединений:**
  * **Левое внешнее соединение (`LEFT [OUTER] JOIN`):** Возвращает все строки из левой таблицы (указанной слева от `JOIN`) и соответствующие строки из правой таблицы. Если в правой таблице нет соответствия, поля правой таблицы заполняются `NULL`.
  * **Правое внешнее соединение (`RIGHT [OUTER] JOIN`):** Возвращает все строки из правой таблицы и соответствующие строки из левой таблицы. Если в левой таблице нет соответствия, поля левой таблицы заполняются `NULL`.
  * **Полное внешнее соединение (`FULL [OUTER] JOIN`):** Возвращает все строки из обеих таблиц. Если для строки из одной таблицы нет соответствия в другой, поля из этой другой таблицы заполняются `NULL`.

---

## 20. Перечислите основные агрегатные функции. В чем их отличие от строковых функций.

**Основные агрегатные функции:**

Агрегатные функции (Aggregate Functions) работают над набором строк (группой) и возвращают одно скалярное значение для всей группы.

* `COUNT(*)`: Подсчитывает общее число строк в группе.
* `COUNT(имя_столбца)`: Подсчитывает число строк, в которых указанное поле имеет непустое (не NULL) значение. С модификатором `DISTINCT` подсчитывает число разных значений.
* `SUM(имя_столбца)`: Вычисляет сумму значений в указанном числовом столбце.
* `AVG(имя_столбца)`: Вычисляет среднее арифметическое значений в указанном числовом столбце.
* `MAX(имя_столбца)`: Находит максимальное значение в указанном столбце.
* `MIN(имя_столбца)`: Находит минимальное значение в указанном столбце.

**Отличие от строковых функций:**

| Характеристика | Агрегатные функции | Строковые функции |
| :--- | :--- | :--- |
| **Уровень применения** | Работают над **группой строк** (или всей таблицей). | Работают над **одной строкой** (кортежем). |
| **Результат** | Возвращают **одно значение** для всей группы. | Возвращают **одно значение** для каждой строки входного набора. |
| **Пример использования** | `SELECT AVG(reiting) FROM S` — одна строка с одним числом. | `SELECT lower(name) FROM S` — столько же строк, сколько в `S`, каждая содержит преобразованное имя. |

---

## 21. Что помимо имен столбцов может стоять в целевом списке?

Целевой список (спецификатор `SELECT`) может содержать не только простые имена столбцов, но и различные выражения:

1. **Выражения с вычислениями:** Арифметические операции над столбцами и константами.
   * *Пример:* `SELECT kol * ves AS вес_поставки FROM SPJ JOIN P ON SPJ.n_det=P.n_det`
2. **Функции:**
   * *Агрегатные:* `SELECT COUNT(*) AS кол_поставок FROM SPJ`
   * *Строковые:* `SELECT upper(name) AS заглавными FROM S`
   * *Другие:* `SELECT current_date` (текущая дата)
3. **Константы:** Фиксированные значения.
   * *Пример:* `SELECT name, 'Поставщик' AS тип FROM S`
4. **Операторы конкатенации:** Объединение строк.
   * *Пример:* `SELECT name || ' (' || n_post || ')' AS полное_имя FROM S`
5. **Подзапросы:** Коррелированные или некоррелированные подзапросы, возвращающие единственное значение (одну строку, один столбец).
   * *Пример:* `SELECT s.name, (SELECT MAX(kol) FROM SPJ spx WHERE spx.n_post=s.n_post) AS макс_объем FROM S s`

---

## 22. Перечислите разделы (секции) оператора select. В каких разделах может использоваться подзапрос, а в каких - нет?

**Разделы оператора `SELECT` (в строгом порядке):**

1. `SELECT` (обязательный)
2. `FROM` (обязательный)
3. `JOIN` (может быть несколько)
4. `WHERE`
5. `GROUP BY`
6. `HAVING`
7. `ORDER BY`
8. `LIMIT` / `OFFSET` (часто используется, хотя в стандарте ANSI/SQL нет)

**Использование подзапросов:**

Подзапросы могут использоваться практически во всех секциях, кроме `SELECT`, `FROM`, `JOIN` и `ORDER BY`, где они применяются особым образом.

* **Может использоваться:**
  
  * **`WHERE`:** Самое частое место. Используется с операторами `IN`, `ANY`, `ALL`, `EXISTS`, `NOT EXISTS`, а также для сравнения с одним значением.
    * *Пример:* `... WHERE n_post IN (SELECT ...)`
  * **`HAVING`:** Аналогично `WHERE`, но применяется к группам после агрегирования.
    * *Пример:* `... HAVING AVG(kol) > (SELECT ...)`
  * **Целевой список `SELECT`:** Только если подзапрос является **коррелированным** и возвращает **единственное значение** (одну строку, один столбец).
    * *Пример:* `SELECT name, (SELECT MAX(...) FROM ... WHERE ...) AS max_val FROM S`
  * **`FROM`:** Подзапрос можно использовать для создания **виртуальной таблицы** (производной таблицы).
    * *Пример:* `SELECT * FROM (SELECT n_det, SUM(kol) FROM SP GROUP BY n_det) AS summary`
  * **`JOIN`:** Виртуальная таблица из подзапроса может быть объектом соединения.
    * *Пример:* `... FROM S JOIN (SELECT ...) AS t ON ...`
* **Не может использоваться (напрямую):**
  
  * **`ORDER BY`:** Нельзя написать `ORDER BY (SELECT ...)`. Однако можно отсортировать по имени столбца, который был создан с помощью подзапроса в `SELECT` (например, `ORDER BY max_val`).
  * **`GROUP BY`:** Нельзя указать подзапрос в качестве поля группировки. Группировка происходит по реальным или вычисленным полям из источников в `FROM`.

---

## 23. Что такое внутреннее соединение?

**Внутреннее соединение (Inner Join)** — это базовый вид операции соединения двух таблиц. Оно возвращает только те строки, для которых существует соответствие (совпадение значений ключевых полей) в **обеих** таблицах.

* **Как работает:** Система сравнивает строки из первой таблицы со строками из второй таблицы по условию, указанному в `ON`. Только те пары строк, которые удовлетворяют этому условию, попадают в результат. Все остальные строки "отбрасываются".
* **Ключевое слово:** `INNER JOIN` (ключевое слово `INNER` часто опускается, и пишут просто `JOIN`).
* **Пример:** Запрос `SELECT S.name, SP.kol FROM SP JOIN S ON SP.n_post = S.n_post` вернет имена поставщиков и объемы поставок только для тех случаев, когда в таблице `SP` есть ссылка на существующего поставщика в таблице `S`. Если бы в таблице `SP` была поставка с `n_post='S9'`, которой нет в таблице `S`, эта строка не попала бы в результат.

---

## 24. Как реализован в SQL квантор существования?

В языке SQL квантор существования (EXISTS) реализуется с помощью логического предиката `EXISTS`.

* **Назначение:** Предикат `EXISTS` проверяет, существует ли хотя бы одна строка в результате выполнения подзапроса. Он возвращает `TRUE`, если подзапрос возвращает непустой набор данных (хотя бы одну строку), и `FALSE`, если подзапрос не возвращает ни одной строки.
* **Синтаксис:**
  
  ```sql
  EXISTS (подзапрос)
  ```
* **Как работает:** Это всегда коррелированный подзапрос, который выполняется для каждой строки внешнего запроса. Система не обязательно вычисляет весь результат подзапроса; как только находится первая подходящая строка, значение `EXISTS` становится `TRUE`, и подзапрос прекращается (это делает его эффективным).
* **Пример из материалов:**  классический пример:
  
  ```sql
  Select фамилия from S where exists (
      Select * from SP 
      where номер_поставщика = S.номер_поставщика and номер_детали='P2'
  )
  ```
  
  Этот запрос читается как: "Выбрать фамилии поставщиков, для которых существует запись в таблице поставок, где номер поставщика совпадает и деталь — P2". Он эквивалентен запросу с `IN`, но часто более эффективен.

---

## 25. Как реализован в SQL квантор всеобщности?

В SQL нет прямого ключевого слова для квантора всеобщности (FOR ALL). Однако его можно логически выразить через квантор существования, используя правило двойного отрицания:

**"Для всех X верно P(X)" эквивалентно "Не существует X, для которого неверно P(X)".**

* **Реализация:** Эта логическая эквивалентность реализуется с помощью конструкции `NOT EXISTS (...)`.
* **Пример из материалов:** самый известный пример — поиск поставщиков, которые поставляют **все** детали:
  
  ```sql
  Select фамилия from S where not exists (
      Select * from P 
      where not exists (
          Select * from SP 
          where номер_поставщика = S.номер_поставщика and номер_детали=P.номер_детали
      )
  )
  ```
  
  Логика этого запроса следующая:
  
  1. Внутренний подзапрос (`where not exists (...)`) ищет детали, которые данный поставщик `S` **не поставляет**.
  2. Если такой детали **нет**, значит, поставщик поставляет все детали.
  3. Внешний `not exists` проверяет, что **не существует** детали, которую поставщик не поставляет.
     Таким образом, условие `not exists ( ... not exists ... )` означает "для всех деталей существует поставка".

---

## 26. В каких случаях вместо фразы in можно использовать операцию сравнения?

Операцию сравнения (например, `=`, `<>`) можно использовать **вместо** `IN` только в том случае, когда подзапрос, используемый в правой части условия, **гарантированно возвращает ровно одно значение** (одну строку и один столбец).

* **Почему это важно:** Оператор `=` сравнивает два скалярных значения. Если подзапрос возвращает несколько значений, возникает ошибка, так как нельзя сравнить одно значение со списком напрямую с помощью `=`. Оператор `IN`, напротив, предназначен именно для проверки принадлежности одного значения множеству других значений.
* **Пример из материалов:** пример, где `IN` используется для сравнения с несколькими значениями:
  
  ```sql
  Select фамилия from S where номер_поставщика in(
      Select номер_поставщика from SP where номер_детали='P2'
  )
  ```
  
  Здесь подзапрос может вернуть несколько поставщиков, поэтому `IN` обязателен.
* **Пример замены `IN` на `=`:** Если мы точно знаем, что запрашиваемое значение уникально (например, первичный ключ), можно использовать `=`:
  
  ```sql
  Select фамилия from S where город = (
      Select город from S where номер_поставщика='S1'
  )
  ```
  
  Подзапрос `(Select город from S where номер_поставщика='S1')` вернет ровно одно значение, поэтому безопасно использовать `=`.

---

##27. Какие существуют средства группирования в SQL? Как они используются?

Основное средство группирования в SQL — это спецификатор `GROUP BY`.

* **Назначение:** Оператор `GROUP BY` разделяет строки, возвращенные оператором `FROM` и `WHERE`, на группы. Все строки в одной группе имеют одинаковые значения в указанных в `GROUP BY` столбцах. Далее агрегатные функции (например, `SUM`, `COUNT`, `AVG`) применяются к каждой группе, возвращая по одному результату на группу.
* **Синтаксис:**
  
  ```sql
  SELECT список_столбцов, агрегатная_функция(...)
  FROM имя_таблицы
  [WHERE условие]
  GROUP BY столбец1, столбец2, ...
  ```
* **Правила использования:**
  
  1. В целевом списке `SELECT` могут находиться только:
     * Имена столбцов, перечисленные в `GROUP BY`.
     * Результаты агрегатных функций (например, `SUM(kol)`).
  2. `GROUP BY` должен следовать после `FROM` и `WHERE`, но перед `HAVING`, `ORDER BY`.
* **Фильтрация групп:** Для фильтрации самих групп (а не отдельных строк) используется спецификатор `HAVING`. Условие в `HAVING` применяется после группировки и может содержать агрегатные функции.
* **Пример из материалов:**
  
  ```sql
  Select номер_детали, sum(количество) 
  from SP 
  where номер_поставщика<>'S1' 
  group by номер_детали
  ```
  
  Этот запрос формирует группы по каждому уникальному значению `номер_детали`, затем для каждой группы суммирует количество поставок (`sum(количество)`).

